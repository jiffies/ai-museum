<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Polymarket äº¤æ˜“åˆ†æå·¥ä½œå°</title>
    <!-- åº“ä¾èµ– -->
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        /* --- åŸºç¡€æ ·å¼å˜é‡ (Light Theme) --- */
        :root {
            --bg: #f3f4f6;
            --header-bg: #ffffff;
            --card-bg: #ffffff;
            --text-main: #111827;
            --text-sub: #6b7280;
            --border: #e5e7eb;
            --accent: #2563eb; 
            
            --up-color: #10b981;  
            --down-color: #ef4444; 
            --risk-color: #f59e0b;
            --line-color: #3b82f6;
            --grid-line: #e5e7eb;
            --axis-line: #9ca3af;
            
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }

        body { margin: 0; padding: 0; background: var(--bg); color: var(--text-main); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }

        /* --- é¡¶éƒ¨ Header --- */
        header {
            background: var(--header-bg);
            border-bottom: 1px solid var(--border);
            padding: 12px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 4px rgba(0,0,0,0.02);
            z-index: 50;
            gap: 20px;
        }
        .app-title { font-size: 18px; font-weight: 700; color: var(--text-main); display: flex; align-items: center; gap: 10px; white-space: nowrap; }
        .app-title span { font-size: 12px; font-weight: 400; color: var(--text-sub); background: #f3f4f6; padding: 2px 8px; border-radius: 12px; }

        /* API è¾“å…¥åŒºåŸŸ */
        .api-input-area {
            display: flex; gap: 8px; flex: 1; align-items: center; justify-content: flex-end;
        }
        .input-group { display: flex; gap: 8px; align-items: center; }
        .input-text {
            padding: 6px 10px; border: 1px solid var(--border); border-radius: 6px; font-size: 13px; width: 140px; transition: border-color 0.2s;
        }
        .input-text:focus { outline: none; border-color: var(--accent); }
        .input-text.wide { width: 280px; } /* åœ°å€æ¡†å®½ä¸€ç‚¹ */
        
        .btn-primary {
            background: var(--accent); color: white; border: none; padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; transition: background 0.2s; white-space: nowrap;
        }
        .btn-primary:hover { background: #1d4ed8; }
        .btn-primary:disabled { background: #9ca3af; cursor: not-allowed; }

        .divider { height: 24px; width: 1px; background: var(--border); margin: 0 4px; }

        /* --- Tab å¯¼èˆª --- */
        .tabs { display: flex; gap: 4px; background: #f3f4f6; padding: 4px; border-radius: 8px; margin-right: auto; margin-left: 20px;}
        .tab-btn {
            border: none; background: transparent; padding: 6px 16px; border-radius: 6px; font-size: 14px; color: var(--text-sub); cursor: pointer; font-weight: 500; transition: all 0.2s; white-space: nowrap;
        }
        .tab-btn.active { background: white; color: var(--accent); box-shadow: 0 1px 2px rgba(0,0,0,0.05); font-weight: 600; }

        /* --- ä¸»å†…å®¹åŒº --- */
        main { flex: 1; position: relative; overflow: hidden; }
        .page { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow-y: auto; display: none; padding: 20px; box-sizing: border-box; }
        .page.active { display: block; }
        #page-dynamic { padding: 0; overflow: hidden; }

        /* --- é€šç”¨ç»„ä»¶ --- */
        .card { background: var(--card-bg); border: 1px solid var(--border); border-radius: 12px; padding: 20px; margin-bottom: 20px; box-shadow: var(--shadow); }
        .card h2 { margin: 0 0 15px 0; font-size: 16px; font-weight: 600; color: #374151; display: flex; justify-content: space-between; }
        .row { display: flex; gap: 20px; flex-wrap: wrap; }
        .col { flex: 1; min-width: 300px; }
        
        .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #e5e7eb; background: #f9fafb; color: #4b5563; margin-left: 8px; vertical-align: middle;}
        .pill.good { color: var(--up-color); background: #ecfdf5; border-color: #a7f3d0; }
        .pill.bad { color: var(--down-color); background: #fef2f2; border-color: #fecaca; }

        /* --- é™æ€ç»Ÿè®¡ CSS --- */
        .meta-container { margin-bottom: 15px; background: #f9fafb; border-radius: 8px; padding: 10px 12px; border: 1px solid var(--border); }
        .meta-row { display: flex; align-items: baseline; margin-bottom: 4px; font-size: 13px; }
        .meta-row:last-child { margin-bottom: 0; }
        .meta-label { width: 70px; font-weight: 600; color: var(--text-sub); flex-shrink: 0; }
        .meta-val { flex: 1; color: var(--text-main); font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: help; }

        .kpi-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; }
        .kpi-box { background: #f9fafb; border: 1px solid var(--border); border-radius: 8px; padding: 12px; min-height: 70px; display: flex; flex-direction: column; justify-content: center;}
        .kpi-label { font-size: 12px; color: var(--text-sub); margin-bottom: 4px; }
        .kpi-value { font-size: 18px; font-weight: 700; color: var(--text-main); line-height: 1.2; }
        .kpi-sub { font-size: 11px; color: #6b7280; margin-top: 4px; }
        
        .analysis-text-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
        .analysis-col h3 { margin: 0 0 10px 0; font-size: 14px; color: var(--text-main); font-weight: 600; }
        .analysis-col p { margin: 6px 0; font-size: 13px; line-height: 1.5; color: var(--text-sub); }
        .analysis-col b { color: var(--text-main); }

        canvas.static-chart { width: 100%; height: 360px; background: #ffffff; border: 1px solid var(--border); border-radius: 8px; cursor: crosshair; }
        
        .tbl { width: 100%; border-collapse: collapse; font-size: 13px; }
        .tbl th { text-align: left; padding: 10px; border-bottom: 2px solid var(--border); color: var(--text-sub); font-weight: 600; background: #f9fafb; position: sticky; top: 0; }
        .tbl td { padding: 8px 10px; border-bottom: 1px solid var(--border); color: var(--text-main); }
        .tbl tr:hover { background: #f9fafb; }
        
        .tooltip { position: fixed; pointer-events: none; background: rgba(255,255,255,0.95); border: 1px solid var(--border); color: var(--text-main); padding: 8px 12px; border-radius: 8px; font-size: 12px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); display: none; z-index: 9999; line-height: 1.5; }

        /* --- åŠ¨æ€æ¼”ç¤º CSS --- */
        #chart-container { position: relative; width: 100%; height: 100%; background: #ffffff; }
        .dynamic-overlay { position: absolute; top: 20px; left: 20px; z-index: 20; display: flex; flex-direction: column; gap: 10px; pointer-events: none; }
        .overlay-panel { background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(4px); padding: 12px; border-radius: 8px; border: 1px solid var(--border); box-shadow: var(--shadow); pointer-events: auto; }
        .legend-row { display: flex; align-items: center; gap: 12px; font-size: 12px; color: var(--text-main); margin-top: 4px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; }
        .bg-up { background-color: var(--up-color); }
        .bg-down { background-color: var(--down-color); }
        
        /* å…¨å®½æ§åˆ¶æ¡ + æ»‘å— */
        .controls-container {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95); border: 1px solid var(--border);
            border-radius: 12px; padding: 12px 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15); z-index: 30; transition: opacity 0.3s;
            display: flex; flex-direction: column; gap: 10px;
            width: 95%; max-width: 1000px; /* åŠ å®½è‡³ 1000px */
        }
        .controls-container.disabled { opacity: 0.5; pointer-events: none; }

        /* è¿›åº¦æ¡æ ·å¼ */
        .scrubber-row { width: 100%; display: flex; align-items: center; }
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent; cursor: pointer;
        }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 6px; background: #e5e7eb; border-radius: 3px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: var(--accent);
            margin-top: -5px; box-shadow: 0 1px 3px rgba(0,0,0,0.3); transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); }

        .buttons-row { display: flex; align-items: center; justify-content: space-between; width: 100%; }
        .left-btns { display: flex; gap: 12px; align-items: center; flex-shrink: 0; }
        
        .btn-control { background: var(--accent); color: white; border: none; border-radius: 6px; padding: 6px 16px; cursor: pointer; font-size: 13px; font-weight: 600; display: flex; align-items: center; gap: 6px; white-space: nowrap; }
        .btn-control:hover { background: #1d4ed8; }
        .btn-control.secondary { background: #f3f4f6; color: var(--text-main); border: 1px solid #d1d5db; }
        .btn-control.secondary:hover { background: #e5e7eb; }

        /* å·¦ä¸‹è§’ç»Ÿè®¡æ¡å®¹å™¨ */
        .vol-stats {
            position: absolute; bottom: 120px; 
            left: 20px; z-index: 20;
            display: flex; gap: 15px; align-items: flex-end; 
            background: rgba(255,255,255,0.9); padding: 15px 15px; border-radius: 8px; border: 1px solid var(--border);
            opacity: 0; transition: opacity 0.3s;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .vol-stats.active { opacity: 1; }
        .vol-col { display: flex; flex-direction: column; align-items: center; width: 45px; }
        /* å¢åŠ  Cost æ å®½åº¦ */
        .vol-col.wide { width: 55px; } 

        .vol-bar-track { width: 100%; height: 120px; background: #f3f4f6; border-radius: 4px 4px 0 0; position: relative; display: flex; align-items: flex-end; overflow: visible; }
        .vol-bar { width: 100%; border-radius: 4px 4px 0 0; transition: height 0.1s linear; position: relative; min-height: 1px; }
        
        /* å †å Barå®¹å™¨ - å¤–å±‚è´Ÿè´£é«˜åº¦å’Œå®šä½ Label */
        .vol-stacked-wrapper {
            width: 100%;
            position: relative; /* å®šä½ä¸Šä¸‹æ–‡ï¼Œç¡®ä¿ Label éšé«˜åº¦ç§»åŠ¨ */
            transition: height 0.1s linear;
        }
        /* å †å Barå†…éƒ¨è§†è§‰å®¹å™¨ - è´Ÿè´£åœ†è§’å’Œè£åˆ‡ */
        .vol-stacked-inner {
            width: 100%;
            height: 100%;
            border-radius: 4px 4px 0 0;
            overflow: hidden;
            display: flex;
            flex-direction: column; /* ä¸Šç»¿ä¸‹çº¢ */
        }

        /* å †å Barå†…éƒ¨è‰²å— */
        .vol-sub-bar {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #fff;
            font-weight: 700;
            overflow: hidden;
            position: relative;
            text-shadow: 0 1px 1px rgba(0,0,0,0.2);
            transition: height 0.1s linear; /* ä½¿ç”¨ height åšåŠ¨ç”» */
        }

        .vol-val { position: absolute; top: -22px; left: 50%; transform: translateX(-50%); width: 100px; text-align: center; font-size: 12px; font-weight: 700; color: var(--text-main); white-space: nowrap; }
        .vol-label { font-size: 11px; margin-top: 6px; font-weight: 600; text-align: center; white-space: nowrap; color: #4b5563; }
        
        #progress-text { 
            font-size: 13px; color: #4b5563; 
            text-align: right; 
            font-variant-numeric: tabular-nums; 
            white-space: nowrap; 
            flex: 1;
            margin-left: 15px;
            overflow: hidden; text-overflow: ellipsis;
        }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 4px; }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>

<header>
    <div class="app-title">
        Polymarket åˆ†æå·¥ä½œå° <span>V3.8</span>
    </div>
    
    <div class="tabs">
        <button class="tab-btn active" onclick="switchTab('static')">ğŸ“Š é™æ€ç»Ÿè®¡æ‹†è§£</button>
        <button class="tab-btn" onclick="switchTab('dynamic')">â–¶ï¸ åŠ¨æ€äº¤æ˜“å›æ”¾</button>
    </div>

    <div class="api-input-area">
        <div class="input-group">
            <input type="text" id="api-user" class="input-text wide" placeholder="User Address (0x...)">
            <input type="text" id="api-market" class="input-text" placeholder="Market Slug" title="å¦‚: btc-updown-15m-1766558700">
            <button class="btn-primary" id="btn-fetch-api" onclick="loadFromApi()">â¬‡ è·å–æ•°æ®</button>
        </div>
        <div class="divider"></div>
        <div class="input-group">
             <select id="timezone-select" style="padding: 6px; border-radius: 6px; border: 1px solid var(--border); font-size: 12px; background:white;">
                <option value="utc">UTC æ—¶é—´</option>
                <option value="local">æœ¬åœ°æ—¶é—´</option>
            </select>
            <label class="btn-primary" style="background:#4b5563; cursor:pointer;" for="global-file">ğŸ“‚ è¯»æ–‡ä»¶</label>
            <input type="file" id="global-file" accept=".csv" style="display:none;">
        </div>
    </div>
</header>

<main>
    <!-- TAB 1: é™æ€ç»Ÿè®¡åˆ†æ -->
    <div id="page-static" class="page active">
        <div class="card">
            <h2>æ¦‚è§ˆ</h2>
            
            <!-- Metadata Info -->
            <div class="meta-container" id="meta-info">
                <div style="text-align:center; color:var(--text-sub); font-size:13px;">è¯·é€šè¿‡ä¸Šæ–¹è¾“å…¥ API å‚æ•°è·å–æ•°æ®ï¼Œæˆ–ä¸Šä¼  CSV æ–‡ä»¶</div>
            </div>

            <div class="kpi-grid" id="kpi-container">
                <!-- KPIs will be injected here -->
            </div>
            
            <div class="analysis-text-grid">
                <div class="analysis-col" id="pnl-col">
                    <h3>ç›ˆåˆ©/æˆæœ¬æ‹†è§£</h3>
                    <div id="pnl-text"></div>
                </div>
                <div class="analysis-col" id="risk-col">
                    <h3>é£é™©æ•å£ (Legging æš´éœ²)</h3>
                    <div id="risk-text"></div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col card">
                <h2>å›¾ 1ï¼šæˆäº¤ä»·æ ¼æ•£ç‚¹ (Up/Down)</h2>
                <canvas id="c1" class="static-chart"></canvas>
            </div>
            <div class="col card">
                <h2>å›¾ 2ï¼šVWAP å‡ä»· (åˆ†é’Ÿçº§)</h2>
                <canvas id="c2" class="static-chart"></canvas>
            </div>
        </div>

        <div class="row">
            <div class="col card">
                <h2>å›¾ 3ï¼šé€ç§’å‡€æŒä»“ (Up - Down)</h2>
                <canvas id="c3" class="static-chart"></canvas>
            </div>
            <div class="col card">
                <h2>å›¾ 4ï¼šæˆäº¤é‡åˆ†å¸ƒç›´æ–¹å›¾ (Size Distribution)</h2>
                <canvas id="c4" class="static-chart"></canvas>
            </div>
        </div>

        <div class="card">
            <h2>é£é™©æ—¶åˆ» Top 20 (æŒ‰å‡€æŒä»“ç»å¯¹å€¼)</h2>
            <div style="max-height: 300px; overflow-y: auto;">
                <table class="tbl" id="top-table">
                    <thead>
                        <tr><th>æ—¶é—´</th><th>ç´¯è®¡ Up</th><th>ç´¯è®¡ Down</th><th>å‡€æŒä»“ (å·®å€¼)</th><th>æœªé…å¯¹æˆæœ¬æš´éœ²(USDC)</th></tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- TAB 2: åŠ¨æ€å›æ”¾ -->
    <div id="page-dynamic" class="page">
        <div id="chart-container"></div>
        <div class="dynamic-overlay">
            <div class="overlay-panel">
                <div style="font-weight: 600; font-size: 14px; margin-bottom: 5px;">é•œåƒå›æ”¾è§†å›¾</div>
                <div class="legend-row"><span style="color:#10b981; font-weight:bold;">â†‘ Yes (Up)</span><span style="color:#ef4444; font-weight:bold;">â†“ No (Down)</span></div>
                <div class="legend-row"><span class="dot bg-up"></span> Buy (ä¹°) <span class="dot bg-down"></span> Sell (å–)</div>
                <div class="legend-row" style="margin-top:6px; border-top:1px solid #eee; padding-top:6px;">
                    <span>â— Maker (åœ†å½¢)</span> &nbsp; <span>â–  Taker (æ–¹å½¢/X)</span>
                </div>
                <div style="margin-top: 5px; font-size: 11px; color: var(--text-sub);">* Yè½´ï¼šä¸ŠåŠåŒºä¸º Yesï¼Œä¸‹åŠåŒºä¸º No(è´Ÿ)</div>
                <div style="margin-top: 5px; display: flex; align-items: center; gap: 5px;">
                    <input type="checkbox" id="chk-force-desc"> <label for="chk-force-desc" style="font-size: 11px; color: var(--text-sub);">å¼ºåˆ¶å€’åºè§£æ</label>
                </div>
            </div>
        </div>
        
        <!-- å·¦ä¸‹è§’ç»Ÿè®¡ Bars -->
        <div class="vol-stats" id="vol-panel">
            <!-- 1. Up Volume -->
            <div class="vol-col">
                <div class="vol-bar-track"><div class="vol-bar bg-up" id="bar-up"><div class="vol-val" id="val-up">0</div></div></div>
                <span class="vol-label" style="color:var(--up-color)">UP Vol</span>
            </div>
            <!-- 2. Down Volume -->
            <div class="vol-col">
                <div class="vol-bar-track"><div class="vol-bar bg-down" id="bar-down"><div class="vol-val" id="val-down">0</div></div></div>
                <span class="vol-label" style="color:var(--down-color)">DOWN Vol</span>
            </div>
            <!-- 3. Total Cost Stacked Bar -->
            <div class="vol-col wide">
                <div class="vol-bar-track">
                    <div class="vol-stacked-wrapper" id="bar-cost-wrapper">
                        <!-- å†…å±‚å®¹å™¨è´Ÿè´£åœ†è§’è£åˆ‡ -->
                        <div class="vol-stacked-inner">
                            <!-- Upper Part (Green/Up Cost) -->
                            <div class="vol-sub-bar bg-up" id="bar-cost-up">
                                <span id="val-cost-up">0</span>
                            </div>
                            <!-- Lower Part (Red/Down Cost) -->
                            <div class="vol-sub-bar bg-down" id="bar-cost-down">
                                <span id="val-cost-down">0</span>
                            </div>
                        </div>
                        <!-- Top Label Sum (ä½äºå†…å±‚å®¹å™¨å¤–ï¼Œä½†ç›¸å¯¹äº wrapper å®šä½) -->
                        <div class="vol-val" id="val-cost-total">0</div>
                    </div>
                </div>
                <span class="vol-label">Total Cost</span>
            </div>
        </div>
        
        <!-- å…¨æ–°çš„æ§åˆ¶æ¡ç»“æ„ -->
        <div class="controls-container disabled" id="controls-panel">
            <div class="scrubber-row">
                <input type="range" id="time-scrubber" min="0" max="100" value="0" step="1">
            </div>
            <div class="buttons-row">
                <div class="left-btns">
                    <button class="btn-control" id="btn-play">â–¶ æ’­æ”¾</button>
                    <button class="btn-control secondary" id="btn-view">ğŸ“ åˆ‡æ¢è§†å›¾</button>
                    <button class="btn-control secondary" id="btn-reset">â†º é‡ç½®</button>
                </div>
                <div id="progress-text">ç­‰å¾…æ•°æ®...</div>
            </div>
        </div>
    </div>
</main>

<div id="tip" class="tooltip"></div>

<script>
/* ================= å…¨å±€çŠ¶æ€ ================= */
let GLOBAL_DATA = { rawRows: [] };
const hoverState = { c1: [], c2: [], c3: [], c4: [] };

/* ================= API å®¢æˆ·ç«¯é€»è¾‘ ================= */
const DATA_API_BASE_URL = 'https://data-api.polymarket.com';
const GAMMA_API_BASE_URL = 'https://gamma-api.polymarket.com';
const GAMMA_API_LOCAL_PROXY = '/api/gamma';
const GAMMA_API_PROXIES = [
    {
        name: 'isomorphic-git',
        build: (url) => `https://cors.isomorphic-git.org/${url}`
    },
    {
        name: 'allorigins',
        build: (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`
    }
]; // æœ¬åœ°ç»•è¿‡ Gamma CORS

function pickMarketFromResponse(data) {
    if (!data) return null;
    if (Array.isArray(data)) return data[0] || null;
    if (Array.isArray(data.markets)) return data.markets[0] || null;
    if (Array.isArray(data.data)) return data.data[0] || null;
    return data;
}

function getConditionIdFromMarket(market) {
    if (!market) return '';
    return market.conditionId || market.condition_id || market.condition?.id || market.condition?.conditionId || '';
}

async function fetchMarketBySlug(slug) {
    const url = new URL(`${GAMMA_API_BASE_URL}/markets`);
    url.searchParams.append('slug', slug);
    url.searchParams.append('limit', '1');

    const rawUrl = url.toString();
    console.log(`[API Req] Fetching Market by Slug: ${rawUrl}`);
    const isLocalhost = ['localhost', '127.0.0.1'].includes(window.location.hostname);
    const localProxyUrl = `${GAMMA_API_LOCAL_PROXY}${url.pathname}${url.search}`;

    const fetchJson = async (targetUrl) => {
        const response = await fetch(targetUrl);
        if (!response.ok) {
            console.error(`[API Error] Status: ${response.status} ${response.statusText}`);
            throw new Error(`Gamma API Error: ${response.status}`);
        }
        return response.json();
    };

    let json;
    let lastError = null;
    if (isLocalhost) {
        try {
            console.log(`[API Req] Trying local proxy: ${localProxyUrl}`);
            json = await fetchJson(localProxyUrl);
        } catch (error) {
            lastError = error;
        }
    }
    if (!json) {
        for (const proxy of GAMMA_API_PROXIES) {
            const proxyUrl = proxy.build(rawUrl);
            console.warn(`[API Warn] Gamma CORS, retry via proxy(${proxy.name}): ${proxyUrl}`);
            try {
                json = await fetchJson(proxyUrl);
                lastError = null;
                break;
            } catch (proxyError) {
                lastError = proxyError;
                console.warn(`[API Warn] Proxy failed (${proxy.name}): ${proxyError}`);
            }
        }
    }
    if (!json) throw lastError;
    const market = pickMarketFromResponse(json);
    if (!market) return null;
    return {
        conditionId: getConditionIdFromMarket(market),
        title: market.question || market.title || '',
        slug: market.slug || slug
    };
}

async function fetchPolymarketTrades(params) {
    const url = new URL(`${DATA_API_BASE_URL}/trades`);
    
    if (params.user) url.searchParams.append('user', params.user);
    if (params.market) url.searchParams.append('market', params.market);
    if (params.limit) url.searchParams.append('limit', params.limit);
    if (params.offset !== undefined) url.searchParams.append('offset', params.offset);
    if (params.takerOnly !== undefined) {
        url.searchParams.append('takerOnly', params.takerOnly.toString());
    }

    console.log(`[API Req] Fetching Trades: ${url.toString()}`);

    const response = await fetch(url);
    if (!response.ok) {
        console.error(`[API Error] Status: ${response.status} ${response.statusText}`);
        throw new Error(`API Error: ${response.status}`);
    }
    const json = await response.json();
    console.log(`[API Res] Got ${json.length} trades`);
    return json;
}

async function fetchPolymarketActivity(params) {
    const url = new URL(`${DATA_API_BASE_URL}/activity`);
    
    if (params.user) url.searchParams.append('user', params.user);
    if (params.market) url.searchParams.append('market', params.market);
    if (params.limit) url.searchParams.append('limit', params.limit);
    if (params.offset !== undefined) url.searchParams.append('offset', params.offset);
    if (params.sortBy) url.searchParams.append('sortBy', params.sortBy);
    if (params.sortDirection) url.searchParams.append('sortDirection', params.sortDirection);

    console.log(`[API Req] Fetching Activity: ${url.toString()}`);

    const response = await fetch(url);
    if (!response.ok) {
        console.error(`[API Error] Status: ${response.status} ${response.statusText}`);
        throw new Error(`API Error: ${response.status}`);
    }
    const json = await response.json();
    const list = Array.isArray(json) ? json : (Array.isArray(json?.data) ? json.data : []);
    console.log(`[API Res] Got ${list.length} activities`);
    return list;
}

async function loadFromApi() {
    console.clear();
    console.log("=== Starting Data Fetch ===");
    
    const user = document.getElementById('api-user').value.trim();
    const market = document.getElementById('api-market').value.trim();
    const btn = document.getElementById('btn-fetch-api');
    
    if (!user || user.length !== 42) { alert('è¯·è¾“å…¥æœ‰æ•ˆçš„ User Address (0x...)'); return; }
    
    let marketParam = undefined;
    const marketSlug = market || '';
    let marketInfo = null;
    
    const requestedLimit = 10000; 
    const pageSize = 500;

    try {
        btn.disabled = true;

        if (marketSlug && marketSlug !== '-') {
            btn.textContent = 'è§£æ Market Slug...';
            marketInfo = await fetchMarketBySlug(marketSlug);
            if (!marketInfo || !marketInfo.conditionId) {
                alert('æœªæ‰¾åˆ°è¯¥ Market Slug å¯¹åº”çš„ Condition IDï¼Œè¯·æ£€æŸ¥è¾“å…¥');
                btn.disabled = false;
                btn.textContent = 'â¬‡ è·å–æ•°æ®';
                return;
            }
            marketParam = marketInfo.conditionId;
            console.log(`Market slug resolved: ${marketInfo.slug} -> ${marketParam}`);
        }
        console.log(`Params -> User: ${user}, Market: ${marketParam || '-'}`);
        
        // ============================================
        // 1. è·å–æ‰€æœ‰äº¤æ˜“è®°å½• (takerOnly: false)
        // ============================================
        console.log("--- Phase 1: Fetching ALL Trades ---");
        let allTrades = [];
        let offset = 0;
        
        while (true) {
            btn.textContent = `All Trades: ${allTrades.length}...`;
            console.log(`  [All Trades] offset=${offset}, limit=${pageSize}`);
            
            const trades = await fetchPolymarketTrades({
                user: user,
                market: marketParam,
                takerOnly: false,
                limit: pageSize,
                offset: offset
            });
            
            if (!trades || trades.length === 0) break;
            
            allTrades = allTrades.concat(trades);
            offset += pageSize;
            
            if (requestedLimit && allTrades.length >= requestedLimit) {
                allTrades = allTrades.slice(0, requestedLimit);
                break;
            }
        }
        console.log(`>>> Total All Trades Fetched: ${allTrades.length}`);

        // ============================================
        // 2. è·å– Taker äº¤æ˜“è®°å½• (takerOnly: true)
        // ============================================
        console.log("--- Phase 2: Fetching TAKER Trades ---");
        let takerTrades = [];
        offset = 0;
        
        while (true) {
            btn.textContent = `Taker Trades: ${takerTrades.length}...`;
            console.log(`  [Taker Trades] offset=${offset}, limit=${pageSize}`);

            const trades = await fetchPolymarketTrades({
                user: user,
                market: marketParam,
                takerOnly: true,
                limit: pageSize,
                offset: offset
            });
            
            if (!trades || trades.length === 0) break;
            
            takerTrades = takerTrades.concat(trades);
            offset += pageSize;
            
            if (requestedLimit && takerTrades.length >= requestedLimit) {
                takerTrades = takerTrades.slice(0, requestedLimit);
                break;
            }
        }
        console.log(`>>> Total Taker Trades Fetched: ${takerTrades.length}`);

        // ============================================
        // 3. æ„å»ºäº¤æ˜“ç±»å‹æ˜ å°„ (Maker/Taker)
        // ============================================
        console.log("--- Phase 3: Building OrderType Map ---");
        const takerHashSet = new Set(takerTrades.map(t => t.transactionHash));
        const orderTypeMap = new Map();
        allTrades.forEach(t => {
            if (!t.transactionHash) return;
            orderTypeMap.set(t.transactionHash, takerHashSet.has(t.transactionHash) ? 'taker' : 'maker');
        });

        // ============================================
        // 4. è·å– Activity (åŒ…å« TRADE / MERGE / REDEEM ç­‰)
        // ============================================
        console.log("--- Phase 4: Fetching Activity ---");
        let allActivities = [];
        offset = 0;
        
        while (allActivities.length < requestedLimit) {
            btn.textContent = `Activity: ${allActivities.length}...`;
            const currentLimit = Math.min(pageSize, requestedLimit - allActivities.length);
            
            const activities = await fetchPolymarketActivity({
                user: user,
                market: marketParam,
                limit: currentLimit,
                offset: offset,
                sortBy: 'TIMESTAMP',
                sortDirection: 'DESC'
            });
            
            if (!activities || activities.length === 0) break;
            
            allActivities = allActivities.concat(activities);
            offset += activities.length;
            if (activities.length < currentLimit) break;
        }
        console.log(`>>> Total Activities Fetched: ${allActivities.length}`);

        // ============================================
        // 5. æ•°æ®ä¸€è‡´æ€§éªŒè¯
        // ============================================
        console.log("--- Phase 5: Validating Trades vs Activity ---");

        const allTradesWithType = allTrades.map(t => ({
            ...t,
            orderType: takerHashSet.has(t.transactionHash) ? 'taker' : 'maker'
        }));
        const allTakerTrades = allTradesWithType.filter(t => t.orderType === 'taker');
        const allMakerTrades = allTradesWithType.filter(t => t.orderType === 'maker');

        const activityTrades = allActivities.filter(a => String(a.type || '').toUpperCase() === 'TRADE');
        const allTradeHashes = new Set(allTradesWithType.map(t => t.transactionHash).filter(Boolean));
        const activityTradeHashes = new Set(activityTrades.map(a => a.transactionHash).filter(Boolean));

        const duplicateHashes = new Map();
        allTradesWithType.forEach(t => {
            if (!t.transactionHash) return;
            const count = duplicateHashes.get(t.transactionHash) || 0;
            duplicateHashes.set(t.transactionHash, count + 1);
        });
        const duplicateHashList = Array.from(duplicateHashes.entries()).filter(([_, count]) => count > 1);

        console.log("[getTrades æ•°æ®ç»Ÿè®¡]");
        console.log(`  Taker äº¤æ˜“æ•°: ${allTakerTrades.length}`);
        console.log(`  Maker äº¤æ˜“æ•°: ${allMakerTrades.length}`);
        console.log(`  æ€»äº¤æ˜“è®°å½•æ•°: ${allTradesWithType.length}`);
        console.log(`  å”¯ä¸€ transactionHash æ•°: ${allTradeHashes.size}`);
        console.log(`  é‡å¤ transactionHash æ•°: ${duplicateHashList.length}`);

        console.log("[getActivity æ•°æ®ç»Ÿè®¡]");
        console.log(`  Activity TRADE äº¤æ˜“æ•°: ${activityTrades.length}`);
        console.log(`  Activity TRADE å”¯ä¸€ transaction æ•°: ${activityTradeHashes.size}`);

        const onlyInTrades = Array.from(allTradeHashes).filter(h => !activityTradeHashes.has(h));
        const onlyInActivity = Array.from(activityTradeHashes).filter(h => !allTradeHashes.has(h));

        if (onlyInTrades.length === 0 && onlyInActivity.length === 0) {
            console.log("  âœ… æ•°æ®ä¸€è‡´ï¼šgetTrades å’Œ getActivity çš„ TRADE å“ˆå¸Œå®Œå…¨åŒ¹é…");
        } else {
            console.log("  âš ï¸  æ•°æ®å·®å¼‚:");
            console.log(`    åªåœ¨ getTrades ä¸­: ${onlyInTrades.length} ä¸ªå“ˆå¸Œ`);
            if (onlyInTrades.length > 0 && onlyInTrades.length <= 5) {
                console.log(`    è¯¦æƒ…: ${onlyInTrades.join(', ')}`);
            }
            console.log(`    åªåœ¨ getActivity ä¸­: ${onlyInActivity.length} ä¸ªå“ˆå¸Œ`);
            if (onlyInActivity.length > 0 && onlyInActivity.length <= 5) {
                console.log(`    è¯¦æƒ…: ${onlyInActivity.join(', ')}`);
            }
        }

        // ============================================
        // 6. å¤„ç† Activity å¹¶æŒ‰æ—¶é—´æ’åº
        // ============================================
        console.log("--- Phase 6: Normalizing Activity Rows ---");
        const fallbackTitle = marketInfo?.title || '';
        const fallbackSlug = marketInfo?.slug || marketSlug || '';

        const processedRows = allActivities.map(a => {
            const activityType = String(a.type || '').toUpperCase();
            const size = Number(a.size || 0);
            const rawUsdcSize = Number(a.usdcSize || a.usdc_size || 0);
            const rawPrice = Number(a.price);
            const price = Number.isFinite(rawPrice) && rawPrice > 0 ? rawPrice : (size ? (rawUsdcSize / size) : 0);
            const usdcSize = rawUsdcSize > 0 ? rawUsdcSize : (price * size);
            const transactionHash = a.transactionHash || '';
            const orderType = activityType === 'TRADE' ? (orderTypeMap.get(transactionHash) || '') : '';

            return {
                timestamp: a.timestamp,
                date: new Date(a.timestamp * 1000).toISOString(),
                type: a.type || '',
                side: a.side || '',
                outcome: a.outcome || '',
                price: price,
                size: size,
                usdcsize: usdcSize || 0,
                title: a.title || fallbackTitle,
                name: a.name || '',
                slug: a.slug || fallbackSlug,
                ordertype: orderType,
                transactionHash: transactionHash
            };
        }).filter(r => r.timestamp);

        const finalRows = processedRows.sort((a,b) => a.timestamp - b.timestamp);
        console.log(`Final Total Rows: ${finalRows.length}`);

        if (finalRows.length === 0) {
            alert('æœªæ‰¾åˆ°è¯¥ç”¨æˆ·åœ¨æ­¤å¸‚åœºçš„ä»»ä½•è®°å½• (Activity)ã€‚');
            btn.disabled = false;
            btn.textContent = 'â¬‡ è·å–æ•°æ®';
            return;
        }

        // æ³¨å…¥å…¨å±€æ•°æ®å¹¶æ¸²æŸ“
        GLOBAL_DATA.rawRows = finalRows;
        
        renderStaticModule();
        // é»˜è®¤å–æ¶ˆå¼ºåˆ¶å€’åºï¼Œå› ä¸º API æ•°æ®é€šå¸¸æ˜¯æœ€æ–°çš„åœ¨å‰
        document.getElementById('chk-force-desc').checked = false;
        prepareDynamicModule();
        
        btn.textContent = 'âœ… å®Œæˆ';
        setTimeout(() => { btn.disabled = false; btn.textContent = 'â¬‡ è·å–æ•°æ®'; }, 2000);
        
    } catch (e) {
        console.error("Critical Error in loadFromApi:", e);
        alert('API è¯·æ±‚å¤±è´¥: ' + e.message);
        btn.disabled = false;
        btn.textContent = 'â¬‡ è·å–æ•°æ®';
    }
}

/* ================= å·¥å…·å‡½æ•° ================= */
function parseTs(val) {
    if (!val) return 0;
    const n = Number(val);
    if (!isNaN(n)) return n < 10000000000 ? n * 1000 : n; 
    const d = new Date(val);
    return !isNaN(d.getTime()) ? d.getTime() : 0;
}

function floorDate(d, ms) { return new Date(Math.floor(d.getTime()/ms)*ms); }
function pad2(n) { return String(n).padStart(2,'0'); }

const fmt = {
    money: x => (x||0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2}),
    shares: x => (x||0).toLocaleString('en-US', {maximumFractionDigits: 3}),
    pct: x => ((x||0)*100).toFixed(2) + '%',
    tickNum: (v, range) => {
        if(!Number.isFinite(v)) return '';
        const absMax=Math.max(Math.abs(v), 1e-9);
        if(absMax >= 100) return Math.round(v).toString();
        if(absMax >= 10) return v.toFixed(1);
        if(range < 0.01) return v.toFixed(5);
        if(range < 0.1) return v.toFixed(4);
        return v.toFixed(2);
    },
    timeTick: (ms, gran, utc) => {
        const d=new Date(ms);
        const hh=utc? d.getUTCHours():d.getHours();
        const mm=utc? d.getUTCMinutes():d.getMinutes();
        const ss=utc? d.getUTCSeconds():d.getSeconds();
        if(gran==='min') return `${pad2(hh)}:${pad2(mm)}`;
        return `${pad2(hh)}:${pad2(mm)}:${pad2(ss)}`;
    },
    fullTime: (ms, utc) => {
        const d = new Date(ms);
        if(utc) return d.toISOString().replace('T',' ').split('.')[0]+' UTC';
        return d.toLocaleTimeString();
    }
};

/* ================= é™æ€ç»˜å›¾é€»è¾‘ (Canvas) ================= */
const GRID_X = 5, GRID_Y = 5;

function makeCtx(canvas) {
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.round(rect.width * dpr);
    const h = Math.round(rect.height * dpr);
    if(canvas.width!==w || canvas.height!==h) { canvas.width=w; canvas.height=h; }
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
    return {ctx, w:rect.width, h:rect.height};
}

function clearPlot(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
}

function drawAxes(ctx, w, h, pad, xLabel, yLabel) {
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-line').trim() || '#e5e7eb'; 
    ctx.lineWidth = 1;
    for(let i=0;i<=GRID_X;i++){
        const x=pad.l + (w-pad.l-pad.r)*i/GRID_X;
        ctx.beginPath(); ctx.moveTo(x,pad.t); ctx.lineTo(x,h-pad.b); ctx.stroke();
    }
    for(let i=0;i<=GRID_Y;i++){
        const y=pad.t + (h-pad.t-pad.b)*i/GRID_Y;
        ctx.beginPath(); ctx.moveTo(pad.l,y); ctx.lineTo(w-pad.r,y); ctx.stroke();
    }
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis-line').trim() || '#9ca3af';
    ctx.lineWidth = 1.2;
    ctx.beginPath(); ctx.moveTo(pad.l, pad.t); ctx.lineTo(pad.l, h-pad.b); ctx.lineTo(w-pad.r, h-pad.b); ctx.stroke();
    ctx.fillStyle = '#6b7280'; ctx.font='12px sans-serif';
    ctx.fillText(yLabel, 10, 16);
    ctx.fillText(xLabel, w-pad.r-30, h-10);
}

function drawTickLabels(ctx, w, h, pad, x0, x1, y0, y1, xGran) {
    ctx.fillStyle = '#6b7280'; ctx.font = '11px sans-serif';
    const isUtc = document.getElementById('timezone-select').value === 'utc';
    const yRange = y1-y0;
    for(let i=0; i<=GRID_Y; i++) {
        const y = pad.t + (h-pad.t-pad.b)*i/GRID_Y;
        const v = y1 - (y1-y0)*i/GRID_Y;
        ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
        ctx.fillText(fmt.tickNum(v, yRange), pad.l-8, y);
    }
    for(let i=0; i<=GRID_X; i++) {
        const x = pad.l + (w-pad.l-pad.r)*i/GRID_X;
        const ms = x0 + (x1-x0)*i/GRID_X;
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.fillText(fmt.timeTick(ms, xGran, isUtc), x, h-pad.b+6);
    }
}

function drawTickLabelsXY(ctx, w, h, pad, x0, x1, y0, y1) {
    ctx.fillStyle = '#6b7280'; ctx.font = '11px sans-serif';
    const yRange = y1-y0, xRange = x1-x0;
    for(let i=0; i<=GRID_Y; i++) {
        const y = pad.t + (h-pad.t-pad.b)*i/GRID_Y;
        const v = y1 - (y1-y0)*i/GRID_Y;
        ctx.textAlign='right'; ctx.textBaseline='middle';
        ctx.fillText(fmt.tickNum(v, yRange), pad.l-8, y);
    }
    for(let i=0; i<=GRID_X; i++) {
        const x = pad.l + (w-pad.l-pad.r)*i/GRID_X;
        const v = x0 + (x1-x0)*i/GRID_X;
        ctx.textAlign='center'; ctx.textBaseline='top';
        ctx.fillText(fmt.tickNum(v, xRange), x, h-pad.b+6);
    }
}

function scaleLinear(v, v0, v1, px0, px1) {
    if(v1===v0) return (px0+px1)/2;
    return px0 + (v-v0)*(px1-px0)/(v1-v0);
}
function niceDomain(min, max) {
    if(!Number.isFinite(min) || !Number.isFinite(max)) return [0,1];
    if(min===max) { const d = Math.abs(min)||1; return [min-0.1*d, max+0.1*d]; }
    const pad = (max-min)*0.06;
    return [min-pad, max+pad];
}

/* ================= æ ¸å¿ƒåˆ†æé€»è¾‘ ================= */
function analyzeStatic(rows) {
    const events = rows.map(r => {
        const d = new Date(parseTs(r.timestamp));
        return {
            raw: r, timestamp: d.getTime(), date: d,
            type: (r.type||'').toUpperCase(), outcome: (r.outcome||'').trim(),
            price: Number(r.price||0), size: Number(r.size||0),
            usdcSize: Number(r.usdcsize || r.size*r.price || 0),
            title: r.title || '',
            slug: r.slug || '',
            name: r.name || '',
            orderType: r.ordertype || ''
        };
    }).sort((a,b) => a.timestamp - b.timestamp);

    const trades = events.filter(e => e.type === 'TRADE');
    const merges = events.filter(e => e.type === 'MERGE');
    const redeems = events.filter(e => e.type === 'REDEEM');
    const winner = (redeems.find(r=>r.outcome)?.outcome) || '';

    const upTrades = trades.filter(t => t.outcome.match(/^(Up|Yes)$/i));
    const downTrades = trades.filter(t => t.outcome.match(/^(Down|No)$/i));
    
    // New: Calculate Trade Counts
    const tradeCount = trades.length;
    const makerCount = trades.filter(t => t.orderType.toLowerCase() === 'maker').length;
    const takerCount = trades.filter(t => t.orderType.toLowerCase() === 'taker').length;

    const sum = (arr, fn) => arr.reduce((a,x) => a+fn(x), 0);
    const upShares = sum(upTrades, t=>t.size);
    const downShares = sum(downTrades, t=>t.size);
    const upCost = sum(upTrades, t=>t.usdcSize);
    const downCost = sum(downTrades, t=>t.usdcSize);
    const totalCost = upCost + downCost;
    
    const mergeUSDC = sum(merges, m=>m.usdcSize || m.size);
    const redeemUSDC = sum(redeems, r=>r.usdcSize || r.size);
    const totalRecovered = mergeUSDC + redeemUSDC;
    const profitTotal = totalRecovered - totalCost;

    const paired = Math.min(upShares, downShares);
    const avgUp = upShares>0 ? upCost/upShares : 0;
    const avgDown = downShares>0 ? downCost/downShares : 0;
    let pairedCost = 0;
    if(paired>0) {
        if(downShares <= upShares) pairedCost = (avgUp*paired) + downCost;
        else pairedCost = upCost + (avgDown*paired);
    }
    const pairedSumPrice = paired>0 ? (pairedCost/paired) : 0;
    const arbEdgePerSet = paired>0 ? (1 - pairedSumPrice) : 0;
    const profitPaired = paired * arbEdgePerSet;
    const profitDirection = profitTotal - profitPaired;

    const secMap = new Map();
    trades.forEach(t => {
        const k = floorDate(t.date, 1000).getTime();
        if(!secMap.has(k)) secMap.set(k, {t: new Date(k), up:0, down:0, upCost:0, downCost:0});
        const o = secMap.get(k);
        if(t.outcome.match(/^(Up|Yes)$/i)) { o.up+=t.size; o.upCost+=t.usdcSize; }
        else { o.down+=t.size; o.downCost+=t.usdcSize; }
    });
    const sec = [...secMap.values()].sort((a,b) => a.t - b.t);
    let cumU=0, cumD=0, cumUC=0, cumDC=0;
    sec.forEach(s => {
        cumU += s.up; cumD += s.down;
        cumUC += s.upCost; cumDC += s.downCost;
        s.cumU = cumU; s.cumD = cumD;
        s.imb = cumU - cumD;
        const avgU = cumU ? cumUC/cumU : 0;
        const avgD = cumD ? cumDC/cumD : 0;
        s.unhedgedCost = (s.imb > 0) ? s.imb * avgU : (-s.imb) * avgD;
    });

    const maxAbsImb = sec.reduce((m,s)=>Math.max(m, Math.abs(s.imb)), 0);
    const maxAbsImbItem = sec.reduce((b,s)=> (Math.abs(s.imb)>Math.abs(b?.imb||0) ? s : b), null);
    const avgAbsImb = sec.length ? sec.reduce((a,s)=>a+Math.abs(s.imb),0)/sec.length : 0;
    const maxRisk = sec.reduce((m,s)=>Math.max(m, s.unhedgedCost), 0);
    const maxRiskItem = sec.reduce((b,s)=> (s.unhedgedCost>(b?.unhedgedCost||0) ? s : b), null);

    let secondsOnlyUp=0, secondsOnlyDown=0, secondsBoth=0;
    sec.forEach(s => {
        if(s.up>0 && s.down>0) secondsBoth++;
        else if(s.up>0) secondsOnlyUp++;
        else if(s.down>0) secondsOnlyDown++;
    });

    const minMap = new Map();
    trades.forEach(t => {
        const k = floorDate(t.date, 60000).getTime();
        const key = k + '|' + t.outcome;
        if(!minMap.has(key)) minMap.set(key, {t: new Date(k), outcome:t.outcome, num:0, den:0});
        const o = minMap.get(key);
        o.num += t.price * t.size; o.den += t.size;
    });
    const byMinute = new Map();
    for(const v of minMap.values()){
        if(!byMinute.has(v.t.getTime())) byMinute.set(v.t.getTime(), {t:v.t, Up:null, Down:null});
        const m = byMinute.get(v.t.getTime());
        const vwap = v.den>0 ? v.num/v.den : null;
        if(v.outcome.match(/^(Up|Yes)$/i)) m.Up = vwap;
        else m.Down = vwap;
    }
    const minute = [...byMinute.values()].sort((a,b)=>a.t-b.t)
        .map(m => ({t:m.t, up:m.Up, down:m.Down, sum: (m.Up!=null && m.Down!=null) ? (m.Up+m.Down) : null}));

    const top = [...sec].sort((a,b)=>Math.abs(b.imb)-Math.abs(a.imb)).slice(0, 20);

    return {
        title: events[0]?.title || '', winner, trades, sec, minute, top,
        // New metadata fields
        slug: events[0]?.slug || '',
        userName: events[0]?.name || '(Unknown)',
        totals: {
            upShares, downShares, upCost, downCost, totalCost,
            mergeUSDC, redeemUSDC, totalRecovered, profitTotal,
            paired, avgUp, avgDown, pairedSumPrice, arbEdgePerSet,
            profitPaired, profitDirection,
            secondsOnlyUp, secondsOnlyDown, secondsBoth, secondsWithTrades: sec.length,
            maxAbsImb, avgAbsImb, maxRisk,
            maxAbsImbTime: maxAbsImbItem?.t, maxRiskTime: maxRiskItem?.t,
            tradeCount, makerCount, takerCount // Return counts
        },
        fmtTime: (d) => fmt.fullTime(d.getTime(), false) 
    };
}

/* ================= ç»˜å›¾å‡½æ•° (Plotters) ================= */
function plotTradesScatter(A, canvas) {
    const {ctx,w,h} = makeCtx(canvas);
    clearPlot(ctx,w,h);
    const pad = {l:68, r:16, t:22, b:42};
    const trades = A.trades;
    if(!trades.length) { ctx.fillStyle='#6b7280'; ctx.fillText('æ— æ•°æ®', 20, 30); return; }

    const t0 = trades[0].date.getTime();
    const t1 = trades[trades.length-1].date.getTime();
    const prices = trades.map(x=>x.price).filter(Number.isFinite);
    const [y0,y1] = niceDomain(Math.min(...prices), Math.max(...prices));

    drawAxes(ctx, w, h, pad, 'Time', 'Price');
    drawTickLabels(ctx, w, h, pad, t0, t1, y0, y1, 'sec');

    const pts=[];
    for(const t of trades){
        const x = scaleLinear(t.date.getTime(), t0, t1, pad.l, w-pad.r);
        const y = scaleLinear(t.price, y0, y1, h-pad.b, pad.t);
        const color = t.outcome.match(/^(Up|Yes)$/i) ? '#10b981' : '#ef4444'; // Green/Red
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.65;
        ctx.beginPath(); ctx.arc(x,y,2.2,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
        pts.push({x,y, t, kind:'trade'});
    }
    hoverState.c1 = pts;
}

function plotVWAPSum(A, canvas) {
    const {ctx,w,h} = makeCtx(canvas);
    clearPlot(ctx,w,h);
    const pad = {l:68, r:16, t:22, b:42};
    const data = A.minute.filter(d=>d.sum!=null);
    if(!data.length) { ctx.fillStyle='#6b7280'; ctx.fillText('æ•°æ®ä¸è¶³ (éœ€åŒä¸€åˆ†é’Ÿæœ‰Up/Downæˆäº¤)', 20, 30); return; }

    const x0 = data[0].t.getTime(), x1 = data[data.length-1].t.getTime();
    const ys = data.map(d=>d.sum);
    const [y0,y1] = niceDomain(Math.min(...ys, 0.9), Math.max(...ys, 1.1));

    drawAxes(ctx, w, h, pad, 'Minute', 'VWAP Sum');
    drawTickLabels(ctx, w, h, pad, x0, x1, y0, y1, 'min');

    const yRef = scaleLinear(1, y0, y1, h-pad.b, pad.t);
    ctx.strokeStyle='#9ca3af'; ctx.setLineDash([6,6]); ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(pad.l, yRef); ctx.lineTo(w-pad.r, yRef); ctx.stroke();
    ctx.setLineDash([]);

    ctx.strokeStyle='#3b82f6'; ctx.lineWidth=2; ctx.beginPath();
    const pts=[];
    data.forEach((d,i)=>{
        const x = scaleLinear(d.t.getTime(), x0, x1, pad.l, w-pad.r);
        const y = scaleLinear(d.sum, y0, y1, h-pad.b, pad.t);
        i===0? ctx.moveTo(x,y) : ctx.lineTo(x,y);
        pts.push({x,y, d, kind:'minute'});
    });
    ctx.stroke();
    ctx.fillStyle='#3b82f6';
    for(const p of pts){ ctx.beginPath(); ctx.arc(p.x,p.y,3,0,Math.PI*2); ctx.fill(); }
    hoverState.c2 = pts;
}

function plotImbalance(A, canvas) {
    const {ctx,w,h} = makeCtx(canvas);
    clearPlot(ctx,w,h);
    const pad = {l:68, r:16, t:22, b:42};
    const sec = A.sec;
    if(!sec.length) return;

    const x0 = sec[0].t.getTime(), x1 = sec[sec.length-1].t.getTime();
    const ys = sec.map(s=>s.imb);
    const [y0,y1] = niceDomain(Math.min(...ys), Math.max(...ys));

    drawAxes(ctx, w, h, pad, 'Second', 'Net Position (Up-Down)');
    drawTickLabels(ctx, w, h, pad, x0, x1, y0, y1, 'sec');

    const yZero = scaleLinear(0, y0, y1, h-pad.b, pad.t);
    ctx.strokeStyle='#9ca3af'; ctx.setLineDash([6,6]); ctx.beginPath(); ctx.moveTo(pad.l, yZero); ctx.lineTo(w-pad.r, yZero); ctx.stroke(); ctx.setLineDash([]);

    ctx.strokeStyle='#2563eb'; ctx.lineWidth=1.5; ctx.beginPath();
    const pts=[];
    sec.forEach((s,i)=>{
        const x = scaleLinear(s.t.getTime(), x0, x1, pad.l, w-pad.r);
        const y = scaleLinear(s.imb, y0, y1, h-pad.b, pad.t);
        i===0? ctx.moveTo(x,y) : ctx.lineTo(x,y);
        pts.push({x,y, s, kind:'sec'});
    });
    ctx.stroke();
    hoverState.c3 = pts;
}

function plotSizeHist(A, canvas) {
    const {ctx,w,h} = makeCtx(canvas);
    clearPlot(ctx,w,h);
    const pad = {l:68, r:16, t:22, b:42};
    const trades = A.trades;
    if(!trades.length) return;

    // Use trade sizes
    const sizes = trades.map(t => t.size);
    const xMin = 0;
    const xMax = Math.max(...sizes, 10); // Ensure at least some range
    
    // Binning logic
    const bins = 40;
    const counts = new Array(bins).fill(0);
    const bw = (xMax-xMin) / (bins || 1);

    if(bw <= 0) {
        counts[0] = sizes.length;
    } else {
        for(const v of sizes){
            let idx = Math.floor((v - xMin) / bw);
            if(idx < 0) idx = 0;
            if(idx >= bins) idx = bins - 1;
            counts[idx]++;
        }
    }

    const yMin = 0;
    const yMax = Math.max(...counts, 1);
    const [yy0, yy1] = niceDomain(yMin, yMax);
    // X-axis domain is simply 0 to max size
    const xx0 = xMin; 
    const xx1 = xMax;

    drawAxes(ctx, w, h, pad, 'Trade Size (Shares)', 'Frequency');
    drawTickLabelsXY(ctx, w, h, pad, xx0, xx1, yy0, yy1);

    const barColor = '#8b5cf6'; // Violet color for distinction
    const pts = [];

    for(let i=0; i<bins; i++){
        const c = counts[i];
        if(c === 0) continue;
        const leftV = xMin + i * bw;
        const rightV = xMin + (i + 1) * bw;
        
        const xL = scaleLinear(leftV, xx0, xx1, pad.l, w - pad.r);
        const xR = scaleLinear(rightV, xx0, xx1, pad.l, w - pad.r);
        const yT = scaleLinear(c, yy0, yy1, h - pad.b, pad.t);
        const yB = scaleLinear(0, yy0, yy1, h - pad.b, pad.t);
        
        const ww = Math.max(1, xR - xL - 1);
        const hh = Math.max(0, yB - yT);
        
        ctx.fillStyle = barColor;
        ctx.fillRect(xL, yT, ww, hh);
        
        pts.push({ x: xL + ww / 2, y: yT + 4, binL: leftV, binR: rightV, count: c });
    }
    hoverState.c4 = pts;
}

/* ================= æ¸²æŸ“é€»è¾‘ (UI) ================= */
function renderStaticModule() {
    const tz = document.getElementById('timezone-select').value;
    const A = analyzeStatic(GLOBAL_DATA.rawRows);
    const t = A.totals;
    
    // 1. Render Meta Info (Title, Slug, User)
    const titleVal = `${A.title} (${A.slug})`;
    const userVal = `${A.userName} ${A.rawAddress ? '('+A.rawAddress+')' : ''}`; // Just Name if address not found
    
    document.getElementById('meta-info').innerHTML = `
        <div class="meta-row">
            <div class="meta-label">Market</div>
            <div class="meta-val" title="${titleVal}">${titleVal}</div>
        </div>
        <div class="meta-row">
            <div class="meta-label">User Info</div>
            <div class="meta-val" title="User: ${A.userName}">User: ${A.userName}</div>
        </div>
    `;

    // 2. Render KPIs
    const winStr = A.winner ? `<span class="pill good">Winner: ${A.winner}</span>` : `<span class="pill">Winner æœªçŸ¥ (çœ‹Redeem)</span>`;
    
    const kpis = [
        { l: 'æ€»æˆæœ¬ (USDC)', v: fmt.money(t.totalCost), s: `Up ${fmt.money(t.upCost)} + Down ${fmt.money(t.downCost)}` },
        { l: 'æ€»å›æ”¶ (USDC)', v: fmt.money(t.totalRecovered), s: `MERGE ${fmt.money(t.mergeUSDC)} + REDEEM ${fmt.money(t.redeemUSDC)}` },
        { l: 'å‡€åˆ©æ¶¦ (USDC)', v: fmt.money(t.profitTotal), s: `â‰ˆ ${fmt.pct(t.totalCost? t.profitTotal/t.totalCost:0)} ${winStr}` },
        { l: 'äº¤æ˜“ç¬”æ•° (Trades)', v: t.tradeCount.toLocaleString(), s: `Maker ${t.makerCount} / Taker ${t.takerCount}` },

        { l: 'å¯é…å¯¹ Shares', v: fmt.shares(t.paired), s: `Up ${fmt.shares(t.upShares)} / Down ${fmt.shares(t.downShares)}` },
        { l: 'é…å¯¹å‡ä»·å’Œ', v: (t.paired? (t.pairedSumPrice.toFixed(5)) : 'â€”'), s: `å¥—åˆ©è¾¹ â‰ˆ ${(t.arbEdgePerSet*100).toFixed(3)}%/å¥—` },
        { l: 'é€ç§’åè…¿å³°å€¼', v: fmt.shares(t.maxAbsImb), s: t.maxAbsImbTime? `å‘ç”Ÿï¼š${fmt.fullTime(t.maxAbsImbTime.getTime(), tz==='utc')}`:'â€”' },
        { l: 'æˆæœ¬æ•å£å³°å€¼', v: fmt.money(t.maxRisk), s: t.maxRiskTime? `å‘ç”Ÿï¼š${fmt.fullTime(t.maxRiskTime.getTime(), tz==='utc')}`:'â€”' },
    ];
    // Re-adjust grid for 8 items or keep 4 cols (2 rows)
    document.getElementById('kpi-container').innerHTML = kpis.map(k => `
        <div class="kpi-box"><div class="kpi-label">${k.l}</div><div class="kpi-value" style="font-size:${k.v.length>15?'14px':'18px'}">${k.v}</div><div class="kpi-sub">${k.s}</div></div>
    `).join('');

    // Detailed Text Analysis
    const p1 = t.profitPaired;
    const p2 = t.profitDirection;
    const share = x => t.profitTotal!==0 ? x/t.profitTotal : 0;
    
    document.getElementById('pnl-text').innerHTML = `
        <p>æ€»åˆ©æ¶¦ï¼š<b style="color:${t.profitTotal>=0?'var(--up-color)':'var(--down-color)'}">${fmt.money(t.profitTotal)} USDC</b>ï¼ˆæ€»æˆæœ¬ ${fmt.money(t.totalCost)}ï¼‰</p>
        <p>æ‹†è§£ï¼ˆè¿‘ä¼¼ï¼‰ï¼š</p>
        <p>â€¢ é…å¯¹/å¯ merge æŠ˜ä»·å¥—åˆ©ï¼š<b>${fmt.money(p1)}</b>ï¼ˆçº¦ ${fmt.pct(share(p1))}ï¼‰</p>
        <p>â€¢ å‰©ä½™ï¼ˆæ–¹å‘/æœªå®Œå…¨é…å¯¹/ç»“ç®—å·®å¼‚ï¼‰ï¼š<b>${fmt.money(p2)}</b>ï¼ˆçº¦ ${fmt.pct(share(p2))}ï¼‰</p>
        <p style="font-size:12px; opacity:0.8; margin-top:8px;">æ³¨ï¼šè¿™é‡ŒæŠŠâ€œé…å¯¹å¥—åˆ©â€æŒ‰ <span class="pill">é…å¯¹å‡ä»·å’Œ</span> è®¡ç®—ï¼›çœŸå®æ‹†è§£ä¼šå—æˆäº¤æ—¶åºå½±å“ï¼ˆleggingï¼‰ä¸ç»“ç®—è·¯å¾„å½±å“ã€‚</p>
    `;
    
    const pct = x => t.secondsWithTrades ? x/t.secondsWithTrades : 0;
    document.getElementById('risk-text').innerHTML = `
        <p>é€ç§’æˆäº¤ç»“æ„ï¼š</p>
        <p>â€¢ ä»… Upï¼š<b>${t.secondsOnlyUp}</b> ç§’ï¼ˆ${fmt.pct(pct(t.secondsOnlyUp))}ï¼‰</p>
        <p>â€¢ ä»… Downï¼š<b>${t.secondsOnlyDown}</b> ç§’ï¼ˆ${fmt.pct(pct(t.secondsOnlyDown))}ï¼‰</p>
        <p>â€¢ åŒç§’ä¸¤è¾¹éƒ½æœ‰ï¼š<b>${t.secondsBoth}</b> ç§’ï¼ˆ${fmt.pct(pct(t.secondsBoth))}ï¼‰</p>
        <p style="margin-top:8px;">legging é£æ§ï¼ˆä¼°ç®—ï¼‰ï¼š</p>
        <p>â€¢ å¹³å‡ |åè…¿|ï¼š<b>${fmt.shares(t.avgAbsImb)}</b> shares</p>
        <p>â€¢ å³°å€¼ |åè…¿|ï¼š<b>${fmt.shares(t.maxAbsImb)}</b> shares</p>
        <p>â€¢ å³°å€¼æˆæœ¬æš´éœ²ï¼š<b>${fmt.money(t.maxRisk)}</b> USDC</p>
    `;

    // Charts
    plotTradesScatter(A, document.getElementById('c1'));
    plotVWAPSum(A, document.getElementById('c2'));
    plotImbalance(A, document.getElementById('c3'));
    plotSizeHist(A, document.getElementById('c4'));

    // Table
    document.querySelector('#top-table tbody').innerHTML = A.top.map(s => `
        <tr>
            <td>${fmt.fullTime(s.t.getTime(), tz==='utc')}</td>
            <td>${fmt.shares(s.cumU)}</td>
            <td>${fmt.shares(s.cumD)}</td>
            <td style="color:${s.imb>0?'var(--up-color)':'var(--down-color)'}">${fmt.shares(s.imb)}</td>
            <td>${fmt.money(s.unhedgedCost)}</td>
        </tr>
    `).join('');
    
    // Attach Tooltips
    attachTooltips(A, tz);
}

function attachTooltips(A, tz) {
    const tip = document.getElementById('tip');
    const getUtc = tz==='utc';
    
    const showTip = (e, html) => {
        tip.style.display = 'block';
        tip.style.left = (e.clientX+12)+'px';
        tip.style.top = (e.clientY+12)+'px';
        tip.innerHTML = html;
    };

    ['c1','c2','c3','c4'].forEach((id, idx) => {
        const cvs = document.getElementById(id);
        cvs.onmousemove = e => {
            const pts = hoverState[id];
            if(!pts || !pts.length) { tip.style.display='none'; return; }
            const rect = cvs.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            let best=null, dist=1e9;
            for(const p of pts) {
                const d = (mx-p.x)**2 + (my-p.y)**2;
                if(d < dist) { dist=d; best=p; }
            }
            if(best && dist < 200) {
                let html = '';
                if(id==='c1') {
                    html = `<b>${best.t.outcome}</b><br>${fmt.fullTime(best.t.date.getTime(), getUtc)}<br>Price: ${best.t.price}<br>Size: ${fmt.shares(best.t.size)}`;
                } else if(id==='c2') {
                    html = `<b>VWAP Sum</b><br>${fmt.fullTime(best.d.t.getTime(), getUtc)}<br>Sum: ${best.d.sum.toFixed(4)}`;
                } else if(id==='c3') {
                    html = `<b>Net Position</b><br>${fmt.fullTime(best.s.t.getTime(), getUtc)}<br>Imb: ${fmt.shares(best.s.imb)}`;
                } else if(id==='c4') {
                    html = `<b>Size Range</b><br>Count: ${best.count}<br>Shares: [${Math.round(best.binL)}, ${Math.round(best.binR)})`;
                }
                showTip(e, html);
            } else {
                tip.style.display = 'none';
            }
        };
        cvs.onmouseleave = () => tip.style.display='none';
    });
}

/* ================= åŠ¨æ€å›æ”¾é€»è¾‘ ================= */
let dynamicState = { 
    chart: null, series: null, trades: [], ticks: [], markers: [], activeMarkers: [], idx: 0, 
    playing: false, interval: null, 
    totalUp: 0, totalDown: 0, curUp: 0, curDown: 0, 
    totalUpCost: 0, totalDownCost: 0, curUpCost: 0, curDownCost: 0, // Added Cost State
    isAutoScale: true, cumStats: [] 
};

function prepareDynamicModule() {
    const rows = GLOBAL_DATA.rawRows;
    const isForceDesc = document.getElementById('chk-force-desc').checked;
    const trades = []; 
    let tUp=0, tDown=0, tUpCost=0, tDownCost=0;
    
    rows.forEach((r, i) => {
        if(!r.timestamp || !r.price) return;
        if((r.type||'').toUpperCase() !== 'TRADE') return;
        const outcome = (r.outcome||'').trim();
        const price = Number(r.price); const size = Number(r.size);
        const cost = Math.abs(price * size); // Calculate cost
        
        const side = (r.side||'BUY').toUpperCase();
        const ms = parseTs(r.timestamp);
        const orderType = (r.ordertype || '').toLowerCase();
        
        let displayVal = price; let isYes = false;
        
        if(outcome.match(/^(Down|No)$/i)) { displayVal = -price; } else { isYes = true; }
        
        if(isYes) {
            tUp += size; 
            tUpCost += cost;
        } else {
            tDown += size;
            tDownCost += cost;
        }
        
        trades.push({ idx: i, time: ms/1000, displayVal, size, price, cost, side, isYes, outcome, orderType });
    });
    
    let isFileDesc = false;
    if(trades.length>1) isFileDesc = trades[0].time > trades[trades.length-1].time;
    if(isForceDesc) isFileDesc = true;
    trades.sort((a,b) => {
        if(a.time !== b.time) return a.time - b.time;
        return isFileDesc ? b.idx - a.idx : a.idx - b.idx;
    });
    
    // Pre-calculate cumulative stats for O(1) seeking
    const cumStats = [];
    let curU=0, curD=0, curUC=0, curDC=0;
    
    // Calculate Max Size for Scaling
    let maxTradeSize = 0;
    trades.forEach(t => { if(t.size > maxTradeSize) maxTradeSize = t.size; });
    const minMarkerSize = 0.6; 
    const maxMarkerSize = 4.0;

    const ticks = [], markers = [];
    trades.forEach((t, i) => {
        ticks.push({ time: i, value: t.displayVal });
        
        // Dynamic Size Calculation
        let markerSize = 1;
        if(maxTradeSize > 0) {
             // Map size range [0, maxTradeSize] to [minMarkerSize, maxMarkerSize]
             markerSize = minMarkerSize + (t.size / maxTradeSize) * (maxMarkerSize - minMarkerSize);
        }

        // Shape based on order type when available, default to circle
        let shape = 'circle';
        if (t.orderType === 'taker') shape = 'square';

        markers.push({ 
            time: i, 
            position: 'inBar', 
            shape: shape, 
            size: markerSize, 
            color: (t.side==='BUY') ? '#10b981' : '#ef4444' 
        });
        
        if(t.isYes) { curU += t.size; curUC += t.cost; } 
        else { curD += t.size; curDC += t.cost; }
        
        cumStats.push({ u: curU, d: curD, uc: curUC, dc: curDC });
    });
    
    dynamicState.trades = trades; dynamicState.ticks = ticks; dynamicState.markers = markers;
    dynamicState.totalUp = tUp; dynamicState.totalDown = tDown;
    dynamicState.totalUpCost = tUpCost; dynamicState.totalDownCost = tDownCost;
    dynamicState.cumStats = cumStats;
    
    // Set Slider Max
    const slider = document.getElementById('time-scrubber');
    slider.max = trades.length - 1;
    slider.value = 0;
    
    if(!window.dynamicChart) initDynamicChart();
    resetDynamicPlayer();
    document.getElementById('controls-panel').classList.remove('disabled');
    document.getElementById('progress-text').textContent = `å°±ç»ª: ${trades.length} ç¬”äº¤æ˜“`;
}

function initDynamicChart() {
    const el = document.getElementById('chart-container');
    const chart = LightweightCharts.createChart(el, {
        layout: { background: { type: 'solid', color: '#ffffff' }, textColor: '#333' },
        grid: { vertLines: { color: '#f3f4f6' }, horzLines: { color: '#f3f4f6' } },
        rightPriceScale: { borderColor: '#e5e7eb', autoScale: true },
        timeScale: { borderColor: '#e5e7eb', rightOffset: 20, tickMarkFormatter: (time) => { const t = dynamicState.trades[time]; return t ? new Date(t.time * 1000).toLocaleTimeString() : ''; } },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
    });
    const series = chart.addLineSeries({ color: '#d1d5db', lineWidth: 1, crosshairMarkerVisible: true });
    series.createPriceLine({ price: 0, color: '#9ca3af', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false });
    window.dynamicChart = chart; dynamicState.series = series;
    new ResizeObserver(entries => {
        if(entries.length === 0 || entries[0].target !== el) return;
        const rect = entries[0].contentRect;
        chart.applyOptions({ width: rect.width, height: rect.height });
    }).observe(el);
}

// Optimized Seek Function
function seekTo(index) {
    const idx = parseInt(index);
    if(idx < 0 || idx >= dynamicState.trades.length) return;
    
    dynamicState.idx = idx;
    
    // Slice data for historical view
    const slicedTicks = dynamicState.ticks.slice(0, idx + 1);
    const slicedMarkers = dynamicState.markers.slice(0, idx + 1);
    
    dynamicState.series.setData(slicedTicks);
    dynamicState.series.setMarkers(slicedMarkers);
    dynamicState.activeMarkers = slicedMarkers; // Update active buffer
    
    // Update Stats
    const stat = dynamicState.cumStats[idx];
    dynamicState.curUp = stat.u;
    dynamicState.curDown = stat.d;
    dynamicState.curUpCost = stat.uc;
    dynamicState.curDownCost = stat.dc;
    updateVolUI();
    
    // Center View
    const chart = window.dynamicChart;
    const timeScale = chart.timeScale();
    const range = timeScale.getVisibleLogicalRange();
    if (range) {
        const width = range.to - range.from;
        timeScale.scrollToPosition(width/2, false); 
    }
    
    // Update Info
    const trade = dynamicState.trades[idx];
    const d = new Date(trade.time * 1000);
    const mType = trade.orderType ? (trade.orderType === 'maker' ? 'Maker' : 'Taker') : '';
    const mTypeText = mType ? ` [${mType}]` : '';
    document.getElementById('progress-text').textContent = `[${d.toLocaleTimeString()}] ${trade.side} ${trade.outcome} (${Math.round(trade.size)}) @ ${trade.price}${mTypeText}`;
}

function resetDynamicPlayer() {
    pauseDynamic();
    const maxIdx = dynamicState.ticks.length - 1;
    if (maxIdx < 0) return;

    dynamicState.idx = maxIdx;
    
    // Update Slider
    const slider = document.getElementById('time-scrubber');
    if(slider) slider.value = maxIdx;

    // Show Full Data
    dynamicState.series.setData(dynamicState.ticks);
    dynamicState.series.setMarkers(dynamicState.markers);
    dynamicState.activeMarkers = [...dynamicState.markers]; // Copy all markers

    // Full Stats
    dynamicState.curUp = dynamicState.totalUp;
    dynamicState.curDown = dynamicState.totalDown;
    dynamicState.curUpCost = dynamicState.totalUpCost;
    dynamicState.curDownCost = dynamicState.totalDownCost;
    updateVolUI();

    // Fit Content (Show all)
    window.dynamicChart.timeScale().fitContent();
    
    // Update Info Text (Last Trade)
    const trade = dynamicState.trades[maxIdx];
    if(trade) {
        const d = new Date(trade.time * 1000);
        document.getElementById('progress-text').textContent = `[${d.toLocaleTimeString()}] ${trade.side} ${trade.outcome} (${Math.round(trade.size)}) @ ${trade.price}`;
    }
}

function startDynamic() {
    if(dynamicState.idx >= dynamicState.ticks.length - 1) {
        dynamicState.idx = 0;
        seekTo(0);
    }
    
    dynamicState.playing = true; 
    document.getElementById('btn-play').textContent = 'â¸ æš‚åœ'; 
    document.getElementById('vol-panel').classList.add('active');
    
    dynamicState.interval = setInterval(() => {
        if(dynamicState.idx >= dynamicState.ticks.length - 1) { 
            pauseDynamic(); 
            document.getElementById('btn-play').textContent = 'â–¶ é‡æ’­'; 
            return; 
        }
        
        // Advance
        dynamicState.idx++;
        
        // Update Chart (Optimized: update single point)
        const i = dynamicState.idx;
        const tick = dynamicState.ticks[i];
        const marker = dynamicState.markers[i];
        const trade = dynamicState.trades[i];
        
        dynamicState.series.update(tick);
        if (marker) { 
            dynamicState.activeMarkers.push(marker); 
            dynamicState.series.setMarkers(dynamicState.activeMarkers); 
        }
        
        // Stats
        if(trade.isYes) {
            dynamicState.curUp += trade.size; 
            dynamicState.curUpCost += trade.cost;
        } else {
            dynamicState.curDown += trade.size;
            dynamicState.curDownCost += trade.cost;
        }
        updateVolUI();
        
        // Slider
        const slider = document.getElementById('time-scrubber');
        slider.value = i;
        
        // Centering
        const timeScale = window.dynamicChart.timeScale();
        const range = timeScale.getVisibleLogicalRange();
        if (range) { 
            const width = range.to - range.from; 
            timeScale.scrollToPosition(width / 2, false); 
        }
        
        const d = new Date(trade.time * 1000);
        document.getElementById('progress-text').textContent = `[${d.toLocaleTimeString()}] ${trade.side} ${trade.outcome} (${Math.round(trade.size)}) @ ${trade.price}`;
        
    }, 50);
}

function pauseDynamic() { 
    dynamicState.playing = false; 
    document.getElementById('btn-play').textContent = 'â–¶ ç»§ç»­'; 
    clearInterval(dynamicState.interval); 
}

function updateVolUI() {
    const { curUp, curDown, totalUp, totalDown, curUpCost, curDownCost, totalUpCost, totalDownCost } = dynamicState;
    
    // 1. Update Vol Bars
    const maxVol = Math.max(totalUp, totalDown, 1);
    document.getElementById('val-up').textContent = Math.round(curUp).toLocaleString();
    document.getElementById('bar-up').style.height = (curUp/maxVol*100) + '%';
    document.getElementById('val-down').textContent = Math.round(curDown).toLocaleString();
    document.getElementById('bar-down').style.height = (curDown/maxVol*100) + '%';
    
    // 2. Update Cost Stacked Bar
    const curTotalCost = curUpCost + curDownCost;
    const maxTotalCost = Math.max(totalUpCost + totalDownCost, 1);
    
    // Set container height relative to max cumulative cost
    document.getElementById('bar-cost-wrapper').style.height = (curTotalCost / maxTotalCost * 100) + '%';
    
    // Set internal bar heights (Up Top / Down Bottom)
    // Use % height for smooth transition
    const upPct = curTotalCost > 0 ? (curUpCost / curTotalCost * 100) : 0;
    const downPct = curTotalCost > 0 ? (curDownCost / curTotalCost * 100) : 0;
    
    document.getElementById('bar-cost-up').style.height = upPct + '%';
    document.getElementById('bar-cost-down').style.height = downPct + '%';
    
    // Set Text Labels
    document.getElementById('val-cost-total').textContent = Math.round(curTotalCost).toLocaleString();
    
    // Only show sub-values if they are non-zero
    document.getElementById('val-cost-up').textContent = curUpCost >= 1 ? Math.round(curUpCost).toLocaleString() : '';
    document.getElementById('val-cost-down').textContent = curDownCost >= 1 ? Math.round(curDownCost).toLocaleString() : '';
}

// Scrubber Event
const scrubber = document.getElementById('time-scrubber');
scrubber.addEventListener('input', (e) => {
    // Pause while dragging
    if(dynamicState.playing) pauseDynamic();
    seekTo(e.target.value);
});

document.getElementById('btn-play').addEventListener('click', () => dynamicState.playing ? pauseDynamic() : startDynamic());
document.getElementById('btn-reset').addEventListener('click', resetDynamicPlayer);
document.getElementById('btn-view').addEventListener('click', () => {
    dynamicState.isAutoScale = !dynamicState.isAutoScale;
    document.getElementById('btn-view').textContent = dynamicState.isAutoScale ? 'ğŸ“ åˆ‡æ¢ -1åˆ°1' : 'ğŸ” åˆ‡æ¢ è‡ªåŠ¨ç¼©æ”¾';
    window.dynamicChart.applyOptions({ rightPriceScale: { autoScale: dynamicState.isAutoScale, minValue: dynamicState.isAutoScale ? undefined : -1, maxValue: dynamicState.isAutoScale ? undefined : 1 } });
});

// Global Wiring
document.getElementById('global-file').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if(!file) return;
    const text = await file.text();
    const rows = Papa.parse(text, { header: true, skipEmptyLines: true, dynamicTyping: true }).data;
    GLOBAL_DATA.rawRows = rows.map(r => {
        const n = {}; Object.keys(r).forEach(k => n[k.toLowerCase().trim()] = r[k]); return n;
    }).filter(r => r.timestamp);
    renderStaticModule();
    prepareDynamicModule();
});

document.getElementById('timezone-select').addEventListener('change', () => { if(GLOBAL_DATA.rawRows.length) renderStaticModule(); });
document.getElementById('chk-force-desc').addEventListener('change', () => { if(GLOBAL_DATA.rawRows.length) prepareDynamicModule(); });

window.switchTab = function(tabName) {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    document.querySelector(`.tab-btn[onclick="switchTab('${tabName}')"]`).classList.add('active');
    document.getElementById(`page-${tabName}`).classList.add('active');
    if(tabName === 'dynamic' && window.dynamicChart) window.dynamicChart.timeScale().fitContent();
}
</script>
<script type="module" src="/index.tsx"></script>
</body>
</html>
